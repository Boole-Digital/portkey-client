<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>Portara Vault Test</title>
  <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
  <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
  <style>
    body {
      font-family: system-ui, sans-serif;
      padding: 2rem;
      max-width: 600px;
      margin: auto;
    }
    button {
      padding: 0.6rem 1.2rem;
      margin-right: 1rem;
      background: #2d72d9;
      color: white;
      border: none;
      border-radius: 4px;
      cursor: pointer;
    }
    pre {
      background: #f4f4f4;
      padding: 1rem;
      margin-top: 1rem;
    }
  </style>
</head>
<body>
  <div id="root"></div>

  <script type="module">
    const { useEffect, useRef, useState } = React;

    function PortaraVault({ vaultUrl, onSignup, onSign, onError }) {
      const iframeRef = useRef(null);
      const trustedOrigin = new URL(vaultUrl).origin;

      useEffect(() => {
        const handler = (event) => {
          if (event.origin !== trustedOrigin || event.data?.source !== "iframe") return;
          const { command, result, error } = event.data;
          if (error) return onError(new Error(error));
          if (command === "signup") onSignup(result);
          if (command === "signText") onSign(result);
        };
        window.addEventListener("message", handler);
        return () => window.removeEventListener("message", handler);
      }, []);

      const postMessage = (command, data) => {
        iframeRef.current?.contentWindow?.postMessage({ id: Date.now(), command, data, source: "parent" }, trustedOrigin);
      };

      window.portaraSignup = () => postMessage("signup");
      window.portaraSign = (data) => postMessage("signText", data);

      return React.createElement("iframe", {
        ref: iframeRef,
        src: vaultUrl,
        title: "Portara Vault",
        sandbox: "allow-scripts allow-same-origin",
        allow: "publickey-credentials-create *; publickey-credentials-get *",
        style: { width: 0, height: 0, border: "none" }
      });
    }

    function App() {
      const [walletData, setWalletData] = useState(null);
      const outputRef = useRef(null);

      const write = (msg) => {
        outputRef.current.textContent = msg;
      };

      const create = async () => {
        const result = await navigator.credentials.create({
          publicKey: {
            challenge: crypto.getRandomValues(new Uint8Array(32)), // must be provided by the server in a real scenario

            rp: {
              name: "Example Corp",
              id: window.location.hostname, // optional if same as current domain
            },

            user: {
              id: Uint8Array.from("user-id-1234", c => c.charCodeAt(0)), // must be a byte array
              name: "user@example.com", // username
              displayName: "Example User", // friendly name
            },

            pubKeyCredParams: [
              {
                type: "public-key",
                alg: -7, // ES256 (ECDSA with SHA-256)
              },
              {
                type: "public-key",
                alg: -257, // RS256 (RSASSA-PKCS1-v1_5 with SHA-256)
              }
            ],

            authenticatorSelection: {
              userVerification: "required", // "preferred" or "discouraged" are other options
            },

            timeout: 60000,

            attestation: "none" // or "direct", "indirect" depending on your requirements
          }
        });
      }

      return React.createElement(React.Fragment, null, [
        React.createElement("h1", null, "🔐 Portara Vault Test"),
        React.createElement(PortaraVault, {
          vaultUrl: "http://localhost:3001/index.html",
          onSignup: (data) => {
            setWalletData(data);
            write("✅ Signup:\n" + JSON.stringify(data, null, 2));
          },
          onSign: (data) => write("✍️ Signed Text:\n" + JSON.stringify(data, null, 2)),
          onError: (err) => write("❌ Errorr:\n" + err.message),
        }),
        React.createElement("button", { onClick: () => create() }, "Step 1. Create Key"),
        React.createElement("br"),
        React.createElement("br"),
        React.createElement("button", { onClick: () => portaraSignup() }, "Step 2. Setup two Wallets, one SOL one ETH"),
        React.createElement("br"),
        React.createElement("br"),
        React.createElement("button", {
          onClick: () => {
            if (!walletData?.eth) return alert("Create wallet first.");
            window.portaraSign({
              chain: "eth",
              message: "Step 3. Sign this message with ETH key.",
              cipherText: walletData.eth.cipherText,
              iv: walletData.eth.iv,
              salt: walletData.eth.salt,
            });
          }
        }, "Sign ETH Text"),
        React.createElement("br"),
        React.createElement("br"),
        React.createElement("button", {
          onClick: () => {
            if (!walletData?.solana) return alert("Create wallet first.");
            window.portaraSign({
              chain: "solana",
              message: "Step 4. Sign this message with SOL key.",
              cipherText: walletData.solana.cipherText,
              iv: walletData.solana.iv,
              salt: walletData.solana.salt,
            });
          }
        }, "Sign SOL Text"),
        React.createElement("pre", { ref: outputRef }),
        React.createElement("br"),
        
        React.createElement("p", {},  "Step 5. Try to get the private key"),
        React.createElement("br"),
        React.createElement("p", {},  "Some assumptions: The only secret should be the passkey, the IV, Cyphertext and Salt are assumed to be leaked and in the hands of you the attacker. You dont have physical access to the users machine. Lets set the bar above Metamask level securirity, can you break encryption without passkey? can a passkey from another website break the encryption? Can i see the dycryption? You cant change the code in public/index.html, unless you can show how a attacker could run that domain as an iframe, with changed code on a victims computer, without control of the domain."),
      ]);
    }

    ReactDOM.createRoot(document.getElementById("root")).render(React.createElement(App));
  </script>
</body>
</html>
